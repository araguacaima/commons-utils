/**
 * @(#)JException.java JReversePro - Java Decompiler / Disassembler.
 * Copyright (C) 2000 2001 Karthik Kumar.
 * EMail: akkumar@users.sourceforge.net
 * <p>
 * This program is free software; you can redistribute it and/or modify
 * it , under the terms of the GNU General Public License as published
 * by the Free Software Foundation; either version 2 of the License,
 * or (at your option) any later version.
 * <p>
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program.If not, write to
 * The Free Software Foundation, Inc.,
 * 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 **/
package jreversepro.reflect;

import jreversepro.common.Helper;
import jreversepro.common.JJvmOpcodes;
import jreversepro.common.KeyWords;

import java.util.*;

/**
 * <b>JException</b> is an abstraction of the exception table , that is
 * an optional part of the Method attributes .
 *
 * @author Karthik Kumar.
 */
public class JException {

    /**
     * Map -
     * Key - Handler Pc beginning
     * value -Handler datatype.
     */
    final Map excCatchTable;
    /**
     * Set if the exception handler is for ANY data type for
     * the block - { startpc, endpc }
     */
    private final boolean any;
    /**
     * End Pc of the exception handler
     */
    private final int endPc;
    /**
     * Start Pc of the exception handler.
     */
    private final int startPc;

    /**
     * Constructor.
     *
     * @param rhsStart   StartPc
     * @param rhsEnd     EndPc
     * @param rhsHandler HandlerPc of the first handler block
     *                   for the above mentioned code block.
     * @param rhsType    Handler data type.
     */
    public JException(int rhsStart, int rhsEnd, int rhsHandler, String rhsType) {
        startPc = rhsStart;
        endPc = rhsEnd;
        any = (rhsType.equals(KeyWords.ANY));

        excCatchTable = new HashMap();
        addCatchBlock(rhsHandler, rhsType);
    }

    /**
     * Adds a new catch block to the code block { startpc, endpc }
     *
     * @param rhsHandlerPc Handler Pc
     * @param rhsType      Handler data type.
     */
    public void addCatchBlock(int rhsHandlerPc, String rhsType) {
        rhsType = (rhsType != null) ? rhsType : KeyWords.ANY;
        excCatchTable.put(rhsHandlerPc, rhsType);
    }

    /**
     * @return true. if at least one of the exception handlers
     * is for ANY block. false, otherwise.
     */
    public boolean containsANYCatchBlock() {
        return excCatchTable.containsValue(KeyWords.ANY);
    }

    /**
     * @param obj Object to be compared with.
     * @return if two JException objects are equal.
     * false, otherwise.
     */
    public boolean equals(Object obj) {
        return obj instanceof JException && sameTryBlock((JException) obj);
    }

    /**
     * Checks if the new exception block passed as parameter
     * has the same code block { startpc, endpc } as the current one.
     *
     * @param exc New Exception Block
     * @return Returns true if the code blocks are same for both of
     * them. false, otherwise.
     */
    public boolean sameTryBlock(JException exc) {
        return (startPc == exc.startPc && endPc == exc.endPc);
    }

    /**
     * This minor adjustment of endPc with handler pc is necessary since
     * in some cases the compiled code generated by javac and jikes
     * are different.
     * Jikes generates code such that the endPc of try . block is the
     * beginning of the first handler beginning pc.
     * Javac generates such that the endPc of try..block is
     * 1 less than the one where the handler block begins.
     * <br>
     * Bug with javac/jikes/jreversepro ???
     * Any clues ??
     *
     * @param instructions List of instructions.
     * @return Effective endPc of the try ..block
     * *
     */
    public int getEffectiveEndPc(List instructions) {
        int insIndex = instructions.indexOf(new JInstruction(endPc, JJvmOpcodes.OPCODE_ACONST_NULL, null, true));
        if (insIndex != -1) {
            return ((JInstruction) instructions.get(insIndex)).
                    getNextIndex();
        } else {
            Helper.log("JException Err: " + endPc);
            return endPc;
        }
    }

    /**
     * @return Returns endpc of this code block.
     */
    public int getEndPc() {
        return endPc;
    }

    /**
     * Given a pc, if an exceptiontable entry exists such that the
     * the handler begins with this pc, then the handler type is
     * returned. Else this returns null.
     *
     * @param rhsHandlerPc HandlerPc for which type is queried.
     * @return Handler type of the exception handler, if one
     * exists beginning with rhsHandlerPc. null, otherwise.
     */
    public String getExceptionClass(int rhsHandlerPc) {
        Object obj = excCatchTable.get(rhsHandlerPc);
        if (obj == null) {
            return null;
        } else {
            return (String) obj;
        }
    }

    /**
     * @return Returns the Enumeration of handler types.
     */
    public Enumeration getHandlers() {
        return Collections.enumeration(excCatchTable.entrySet());
    }

    /**
     * @return Returns startpc of this code block.
     */
    public int getStartPc() {
        return startPc;
    }

    /**
     * @return Value of Any
     */
    public boolean isAny() {
        return any;
    }

    /**
     * @return Stringified form of the class.
     */
    public String toString() {
        StringBuilder sb = new StringBuilder("");
        Enumeration enum1 = Collections.enumeration(excCatchTable.keySet());
        Enumeration enum2 = Collections.enumeration(excCatchTable.values());

        while (enum1.hasMoreElements()) {
            sb.append("\t\t").append(startPc).append("\t").append(endPc);
            sb.append("\t").append(enum1.nextElement());
            sb.append(" ").append(enum2.nextElement()).append("\n");
        }
        return sb.toString();
    }
}
